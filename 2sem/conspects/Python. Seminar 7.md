# Классы


`__dir__` - magic-метод, показывающий всё содержимое объекта: метода и поля

`__что-то__` - magic-method

`__init__` - не конструтор; это инициализатор, он вызывается уже после аллокации памяти

Перед `__init__` вызывается `__new__` (аллокатор)

***

super() - предок класса; если много предков, то все операции вызываются в порядке от конца к началу в последовательности определения наследования:

``` python
class Some(A, B):
    def __init__(self):
        super().__new__()
```


Вызовется сначала `B.__new__()`, а потом `A.__init__()`

Если не написать `super().__new__()`, то поля, относящиеся к предку класса, не будут аллоцированны

***

``` python
class Vector:
	def __init__(self, x, y, color='white'):
		print('Initializing...')
		self.x = x
		self.y = y
		self.color = color
		
	def __add__(self, obj2):
		return Vector(self.x + obj2.x, self.y + obj2.y, '{}+{}'.format(self.color, obj2.color))
```

`__add__` - переопределение "плюса".

``` python
> vec1 = Vector(1, 2, 'red')
> vec2 = Vector(3, 4, 'blue')
> print(vec1 + vec2)
> 'red+blue'
```

***

`str` - неизменяемый тип, поэтому лучше использовать `'{}+{}'.format()`, а не `str1 + '+' + str2`, т.к. в последнем случае создаются промежуточные объекты, которые ещё и копируются.

Оператор `+=` для `str` хорошо оптимизирован.

***

`__str__()` - строковое представление, нужно в том числе для `print(vec1)`

Но это не сработает для `print([vec1])`

У строки есть два строковых представления; есть ещё один метод, одно из обоснований - не хочется, чтобы в выводе контейнера разносило содержимое элементов.

Проверьте: `print('a\nb')` и `print(['a\nb'])`

Поэтому параллельно существуют два строковых представления: `__str__()` и `__repr__()` (representation).


Определение метода `__str__()` полезно для дебага.

***

`__eq__()`, `__ge__()`, `__le__()` и т.д. - различные сравнения, в принципе, не обязано возвращать `bool`, но не надо так делать.

``` python
def __eq__(self, obj2):
	return 2
```

``` python
> vec1 == vec2
> 2
```

***

`__radd__()`, `__rmod__()`, `__rxor__()` и т.д. - знак оператора и знак равно (`x += 2` или `g /= 6`)

***

`__abs__()` - модуль

``` python
def __abs__(self):
	return self.x ** 2 + self.y ** 2
```

***

`__int__()`, `__float__()` - конверсии типов

***

`__call__()` - вызов у объекта круглых скобок - `obj()`

Наличие этого метода делает объект callable, проверяется ф-цией `callable()` 

``` python
> callable(int)
> True
> callable(2)
> False
```

***

`__next__()` и `__iter__()` реализуют интерфейс `Iterable`

`__getitem__()` - доступ по индексу в квадратных скобках

``` python
def __getitem__(self, index):
	return [self.x, self.y][index] # Такая реализация вполне неплоха
```

`__len__()` - размер; python умеет итерироваться не только по объектам с `next()`, но и с `__getitem__()` в связке с `__len__()` (нужны оба метода!), но правильней через интерфейс `Iterable`.

***

Member - поле или метод

```
def __getattr__(self, attr_name):
	return ...
	
def __getattribute__(self, attr_name):
	return ...
```

`__getattribute__()` выполняется первым, ищет среди тех member'ов, которые определили вы, потом `__getattr__()`. Важно, что вы сами можете захотеть их использовать, поэтому в контрразведовательных целях не стоит переопределять всё бездумно.

См. [разницу между этими методами](http://qaru.site/questions/26205/difference-between-getattr-vs-getattribute)

``` python
def __setattr__(self, attr_name, attr_value):
	pass
```

Ещё есть `delattr()` и `hasattr()`

***

Можно вызвать явно, или оно само вызовется в конце жизненного цикла объекта.

``` python
def __del__(self):
	# что-то ваше
	super().__del__()
```

***

Контекстные менеджеры:

``` python
with open(name) as f:
	pass
```

(см. [Конспект Полины](https://github.com/paulin-mipt/python-cheatsheets), она обещала написать его)

Это полезные вещи для отслеживания ресурсов. Пример: что-то было открыто, а потом должно быть __обязательно__ закрыто; а вдруг будет исключение? Вот контекстный менеджер в своём `finaly` (неубиваемая штука, всегда будет в конце исполнения) закроет всё, что нужно.
