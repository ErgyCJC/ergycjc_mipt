# Классы

-

`__dir__` - magic-метод, показывающий всё содержимое объекта: метода и поля

`__что-то__` - magic-method

`__init__` - не конструтор; это инициализатор, он вызывается уже после аллокации памяти

Перед `__init__` вызывается `__new__` (аллокатор)

-

super() - предок класса; если много предков, то все операции вызываются в порядке от конца к началу в последовательности определения наследования:

``` python
class Some(A, B):
    def __init__(self):
        super().__new__()
```


Вызовется сначала `B.__new__()`, а потом `A.__init__()`

Если не написать `super().__new__()`, то поля, относящиеся к предку класса, не будут аллоцированны

-

```
class Vector:
	def __init__(self, x, y, color='white'):
		print('Initializing...')
		self.x = x
		self.y = y
		self.color = color
		
	def __add__(self, obj2):
		return Vector(self.x + obj2.x, self.y + obj2.y, '{}+{}'.format(self.color, obj2.color))
```

`__add__` - переопределение "плюса"

```
> vec1 = Vector(1, 2, 'red')
> vec2 = Vector(3, 4, 'blue')
> print(vec1 + vec2)
> 'red+blue'
```

-

str - mutable, поэтому лучше использовать .format(), а не str1 + 'gggggaaaa' + str2

+= для str хорошо оптимизирована

-

`__str__()` - строковое представление, нужно в том числе для `print(vec1)`

Но это не сработает для `print([vec1])`

У строки есть два строковых представления; есть ещё один метод, одно из обоснований - не хочется, чтобы в выводе контейнера разносило содержимое элементов.

Проверь: `print('a\nb')` и `print(['a\nb'])`

Поэтому есть два строковых представлений у всего: `__str__()` и `__repr__()` (representation)


Определение `__str__()` полезно для дебага

-

`__eq__()`, `__ge__()`, `__le__()` и т.д. - различные сравнения, в принципе, не обязано возвращать `bool`, но не надо так делать

```
def __eq__(self, obj2):
	return 2
```

```
> vec1 == vec2
> 2
```

-

`__radd__()`, `__rmod__()`, `__rxor__()` и т.д. - знак оператора и ещё какой-то оператор (`x += 2` или `g /= 6`)

-

`__abs__()` - модуль

```
def __abs__(self):
	return self.x ** 2 + self.y ** 2
```

-

`__int__()`, `__float__()` - конверсии типов

-

`__call__()` - вызов у объекта круглых скобок - `obj()`

Наличие этого метода делает объект callable, проверяется ф-цией `callable()` 

```
> callable(int)
> True
> callable(2)
> False
```

-

`__next__()` и `__iter__()` реализуют интерфейс `Iterable`

`__getitem__()` - доступ по индексу в квадратных скобках

```
def __getitem__(self, index):
	return [self.x, self.y][index] # Такая реализация вполне неплоха
```